
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../cdrom_io.h"
#include "../../cheats.h"
#include "../../file_io.h"
#include "../../hardware.h"
#include "../../menu.h"
#include "../../spi.h"
#include "../../user_io.h"
#include "debug_log.h"
#include "megacd.h"

#define SAVE_IO_INDEX 5 // fake download to trigger save loading

#define MCD_GET_CMD        0
#define MCD_GET_SEND_DATA  1

static int need_reset=0;
static uint8_t has_command = 0;

// Status testing mode - set to true to enable debug cycle through all status codes
static bool MCD_TEST_STATUS_CYCLE = false;

// Test function: cycles through all CDD status codes
// Allows observing BIOS behavior for each status
static void mcd_test_status_cycle()
{
	static const uint8_t test_status_list[] = {
		CD_STAT_NO_DISC,    // 0x0B - No disc inserted
		CD_STAT_OPEN,       // 0x05 - Tray open
		CD_STAT_TOC,        // 0x09 - Reading TOC
		CD_STAT_STOP,       // 0x00 - Ready/Stopped
		CD_STAT_SEEK,       // 0x02 - Seeking
		CD_STAT_PLAY,       // 0x01 - Playing
		CD_STAT_PAUSE,      // 0x04 - Paused
		CD_STAT_SCAN,       // 0x03 - Scanning (FF/RW)
		CD_STAT_END,        // 0x0C - End of disc
	};
	
	static const char* test_status_names[] = {
		"NO_DISC (0x0B)",
		"OPEN (0x05)",
		"TOC (0x09)",
		"STOP (0x00)",
		"SEEK (0x02)",
		"PLAY (0x01)",
		"PAUSE (0x04)",
		"SCAN (0x03)",
		"END (0x0C)",
	};
	
	static int test_index = 0;
	static uint32_t test_timer = 0;
	static uint32_t start_delay = 0;
	static bool initialized = false;
	
	// Wait 3 seconds after boot before starting test (let BIOS initialize)
	if (!start_delay)
	{
		start_delay = GetTimer(3000);
		printf("\x1b[32m[MCD TEST] Waiting 3 seconds before starting...\x1b[0m\n");
		return;
	}
	
	if (!CheckTimer(start_delay))
	{
		return; // Still waiting
	}
	
	// Initialize timer on first run (after delay)
	if (!initialized)
	{
		initialized = true;
		test_timer = GetTimer(2000);
		printf("\x1b[32m[MCD TEST] ===== STATUS CYCLE STARTED =====\x1b[0m\n");
		printf("\x1b[32m[MCD TEST] Will change every 2 seconds.\x1b[0m\n");
		DebugLog("[TEST MODE] Status cycle started. Will change every 2 seconds.\n");
		Info("TEST MODE ACTIVE", 3000);
	}
	
	// Change status every 2 seconds
	if (CheckTimer(test_timer))
	{
		test_timer = GetTimer(2000);
		
		// Update CDD status
		cdd.status = test_status_list[test_index];
		cdd.latency = 0; // Force immediate status report
		
		// Log to console with printf (always works)
		printf("\x1b[33m[MCD TEST] >>> Status: %s (cdd.status = 0x%02X)\x1b[0m\n", 
			test_status_names[test_index], cdd.status);
		
		// Also try OSD and DebugLog
		DebugLog("[TEST] Status: %s\n", test_status_names[test_index]);
		Info(test_status_names[test_index], 2000);
		
		// Cycle to next status
		test_index = (test_index + 1) % 9;
	}
}

// Physical CD state machine
enum PhysicalCDState {
	PCD_IDLE,       // No media detected
	PCD_LOADING,    // TOC being loaded
	PCD_OPENING,    // Signal door open/close to BIOS
	PCD_READY       // Disc ready, BIOS in control
};

void mcd_poll()
{
	static uint32_t poll_timer = 0;
	static uint8_t last_req = 255;
	static uint8_t adj = 0;
	static uint32_t hw_poll_timer = 0;
	
	// Physical CD state
	static PhysicalCDState cd_state = PCD_IDLE;
	static uint32_t load_timer = 0;
	static bool load_attempted = false;

	// TEST MODE: Cycle through status codes manually for BIOS behavior observation
	if (MCD_TEST_STATUS_CYCLE)
	{
		mcd_test_status_cycle();
		// Continue with normal polling to send status to core
	}

	// Throttle hardware polling to every 500ms to prevent UI freeze
	if (!hw_poll_timer || CheckTimer(hw_poll_timer))
	{
		hw_poll_timer = GetTimer(500);

		switch (cd_state)
		{
		case PCD_IDLE:
			// No media → ensure NO_DISC status
			if (!hasCDROMMedia(0))
			{
				if (cdd.loaded)
				{
					cdd.Unload();
					Info("CD Removed", 2000);
					DebugLog("[MISTER] CD removed, unloading\n");
				}
				
				// CRITICAL: Set NO_DISC if not loaded
				// Reset() puts STOP, but we need NO_DISC when no media
				if (!cdd.loaded && cdd.status != CD_STAT_NO_DISC)
				{
					cdd.status = CD_STAT_NO_DISC;
				}
				
				load_attempted = false;
			}
			// Media detected → start loading
			else if (!load_attempted && 
			         (getCDROMType(0) == DISC_MEGACD || getCDROMType(0) == DISC_UNKNOWN))
			{
				cd_state = PCD_LOADING;
				load_timer = GetTimer(100); // Small debounce
				cdd.status = CD_STAT_NO_DISC; // Keep NO_DISC during load
				Info("Disc Inserted...", 2000);
				printf("\x1b[32m[MISTER] ===== DISC INSERTION DETECTED =====\x1b[0m\n");
				printf("[MISTER] State: IDLE → LOADING\n");
				printf("[MISTER] cdd.status = NO_DISC (0x%02X)\n", cdd.status);
				DebugLog("[MISTER] State: IDLE → LOADING\n");
			}
			break;
			
		case PCD_LOADING:
			// Media removed during loading
			if (!hasCDROMMedia(0))
			{
				cd_state = PCD_IDLE;
				load_attempted = false;
				DebugLog("[MISTER] Load aborted - media removed\n");
				break;
			}
			
			// Wait for debounce timer
			if (CheckTimer(load_timer))
			{
				// Attempt to load TOC
				if (!cdd.loaded)
				{
					DebugLog("[MISTER] Loading TOC from physical CD...\n");
					usleep(50000); // 50ms for drive stability
					mcd_set_image(0, ""); // Empty string = physical CD
				}
				
				if (cdd.loaded)
				{
					// Success! Signal OPEN first (BIOS needs to see door open/close)
					cdd.status = CD_STAT_OPEN;
					cdd.latency = 0;
					cd_state = PCD_OPENING;
					load_attempted = true;
					load_timer = GetTimer(500); // Hold OPEN for 500ms
					
					printf("\x1b[32m[MISTER] ===== TOC LOADED SUCCESSFULLY =====\x1b[0m\n");
					printf("[MISTER] State: LOADING → OPENING\n");
					printf("[MISTER] cdd.status = OPEN (0x%02X) - signaling door\n", cdd.status);
					printf("[MISTER] cdd.loaded = %d\n", cdd.loaded);
					DebugLog("[MISTER] TOC loaded. State: LOADING → OPENING\n");
					Info("Closing CD Door...", 500);
				}
				else
				{
					// Failed, retry after 500ms
					load_timer = GetTimer(500);
					DebugLog("[MISTER] TOC load failed, retrying in 500ms...\n");
				}
			}
			break;
			
		case PCD_OPENING:
			// Hold OPEN status briefly, then transition to STOP (door closed)
			if (!hasCDROMMedia(0))
			{
				cd_state = PCD_IDLE;
				load_attempted = false;
				DebugLog("[MISTER] State: OPENING → IDLE (media removed)\n");
				break;
			}
			
			if (CheckTimer(load_timer))
			{
				// Door "closed" - signal STOP (disc ready)
				cdd.status = CD_STAT_STOP;
				cdd.latency = 10; // Standard latency
				cd_state = PCD_READY;
				
				printf("[MISTER] State: OPENING → READY\n");
				printf("[MISTER] cdd.status = STOP (0x%02X) - door closed\n", cdd.status);
				printf("[MISTER] BIOS should now detect disc and request TOC\n");
				DebugLog("[MISTER] State: OPENING → READY. Status = STOP. BIOS in control.\n");
				Info("Press Start Button", 2000);
			}
			break;
			
		case PCD_READY:
			// Media removed while ready
			if (!hasCDROMMedia(0))
			{
				cd_state = PCD_IDLE;
				load_attempted = false;
				DebugLog("[MISTER] State: READY → IDLE (media removed)\n");
			}
			// In READY state, BIOS controls everything via commands
			// We don't change status here - CommandExec() does it
			break;
		}
	}

	if (!poll_timer || CheckTimer(poll_timer))
	{
		if (!cdd.isData && cdd.status == CD_STAT_PLAY && cdd.latency == 0) {
			// Send audio sectors faster so buffer stays filled
			poll_timer = GetTimer(10);
			adj = 0;
		} else {
			poll_timer = GetTimer(13 + (!adj ? 1 : 0));
			if (++adj >= 3) adj = 0;
		}

		if (has_command) {
			spi_uio_cmd_cont(UIO_CD_SET);
			uint64_t s = cdd.GetStatus(0);
			spi_w((s >> 0) & 0xFFFF);
			spi_w((s >> 16) & 0xFFFF);
			spi_w(((s >> 32) & 0x00FF) | (cdd.isData ? 0x01 << 8 : 0x00 << 8));
			DisableIO();

			has_command = 0;

			// Log Status Sent to Core
			uint8_t status_byte = (uint8_t)(s & 0xFF);
			uint8_t stat0_mode = status_byte & 0xF;
			uint8_t stat1_rep = (status_byte >> 4) & 0xF;
			printf("[CORE] < SEND STATUS: 0x%02X (loaded=%d latency=%d)\n", 
				stat0_mode, cdd.loaded, cdd.latency);
			DebugLog("[CORE] < SEND STATUS_WORD: %04X (Mode: %X, Rep: %X, Full: %02X)\n",
				(int)(s & 0xFFFF), stat0_mode, stat1_rep, status_byte);
		}

		cdd.Update();
	}

	uint8_t req = spi_uio_cmd_cont(UIO_CD_GET);
	if (req != last_req)
	{
		last_req = req;

		spi_w(MCD_GET_CMD);

		uint16_t data_in[4];
		data_in[0] = spi_w(0);
		data_in[1] = spi_w(0);
		data_in[2] = spi_w(0);
		DisableIO();

		if (need_reset || data_in[0] == 0xFF) {
			printf("MCD: request to reset\n");
			DebugLog("[CORE] > REQUEST RESET\n");
			need_reset = 0;
			cdd.Reset();
		}

		uint64_t c = *((uint64_t*)(data_in));
		cdd.SetCommand(c, 0);

		// Log Command Received from Core
		printf("[CORE] > RECV COMMAND: 0x%02X\n", (int)(c & 0xFF));
		DebugLog("[CORE] > GET COMMAND: %02X (Arg: %02X)\n", (int)(c & 0xFF), (int)((c >> 8) & 0xFF));

		cdd.CommandExec();
		has_command = 1;

		//printf("\x1b[32mMCD: Get command, command = %04X%04X%04X, has_command = %u\n\x1b[0m", data_in[2], data_in[1], data_in[0], has_command);
	}
	else
		DisableIO();
}

static char buf[1024];
static void mcd_mount_save(const char *filename)
{
	user_io_set_index(SAVE_IO_INDEX);
	user_io_set_download(1);
	if (strlen(filename))
	{
		FileGenerateSavePath(filename, buf);
		user_io_file_mount(buf, 0, 1);
	}
	else
	{
		user_io_file_mount("");
	}
	user_io_set_download(0);
}

static int mcd_load_rom(const char *basename, const char *name, int sub_index)
{
	strcpy(buf, basename);
	char *p = strrchr(buf, '/');
	if (p)
	{
		p++;
		strcpy(p, name);
		if (user_io_file_tx(buf, sub_index << 6)) return 1;
	}

	return 0;
}

void mcd_set_image(int num, const char *filename)
{
	static char last_dir[1024] = {};

	(void)num;

	cdd.Unload();
	cdd.status = CD_STAT_OPEN;

	int same_game = (*filename && *last_dir && !strncmp(last_dir, filename, strlen(last_dir))) || (!*filename && !*last_dir);
	strcpy(last_dir, filename);
	char *p = strrchr(last_dir, '/');
	if (p) *p = 0;

	int loaded = 1;
	if (!same_game)
	{
		mcd_mount_save("");

		user_io_status_set("[0]", 1);
		user_io_status_set("[0]", 0);
		mcd_reset();

		loaded = 0;
		strcpy(buf, last_dir);
		char *p = strrchr(buf, '/');
		if (p)
		{
			strcpy(p + 1, "cd_bios.rom");
			loaded = user_io_file_tx(buf);
		}
		else
		{
			// Fallback for physical CD/empty path: Try known regions
			const char *bios_paths[] = {"/media/fat/games/MegaCD/USA/cd_bios.rom",
			                            "/media/fat/games/MegaCD/Europe/cd_bios.rom",
			                            "/media/fat/games/MegaCD/Japan/cd_bios.rom",
			                            "/media/fat/games/MegaCD/boot.rom"};
			for (int i = 0; i < 4; i++)
			{
				strcpy(buf, bios_paths[i]);
				loaded = user_io_file_tx(buf);
				if (loaded) break;
			}
		}

		if (!loaded)
		{
			sprintf(buf, "%s/boot.rom", HomeDir());
			loaded = user_io_file_tx(buf);
		}

		if (!loaded) Info("CD BIOS not found!", 4000);
	}

	if (loaded && (*filename || hasCDROMMedia(0)))
	{
		if (cdd.Load(filename) > 0)
		{
			cdd.status = cdd.loaded ? CD_STAT_STOP : CD_STAT_NO_DISC;
			cdd.latency = 10;
			cdd.SendData = mcd_send_data;
			cdd.CanSendData = mcd_can_send_data;

			if (!same_game)
			{
				mcd_load_rom(filename, "cd_bios.rom", 0);
				mcd_load_rom(filename, "cart.rom", 1);
				mcd_mount_save(filename);
				cheats_init(filename, 0);
			}
		}
		else
		{
			cdd.status = CD_STAT_NO_DISC;
		}
	}
}

void mcd_reset() {
	need_reset = 1;
}

int mcd_send_data(uint8_t* buf, int len, uint8_t index) {
	// set index byte
	user_io_set_index(index);

	user_io_set_download(1);
	user_io_file_tx_data(buf, len);
	user_io_set_download(0);
	return 1;
}

static char int_blank[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x7D, 0x00, 0x7D, 0x00, 0x7D, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x53, 0x45, 0x47, 0x41, 0x5F, 0x43, 0x44, 0x5F, 0x52, 0x4F, 0x4D, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x52, 0x41, 0x4D, 0x5F, 0x43, 0x41, 0x52, 0x54, 0x52, 0x49, 0x44, 0x47, 0x45, 0x5F, 0x5F, 0x5F,
};

static char ext_blank[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x1F, 0xFD, 0x1F, 0xFD, 0x1F, 0xFD, 0x1F, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x53, 0x45, 0x47, 0x41, 0x5F, 0x43, 0x44, 0x5F, 0x52, 0x4F, 0x4D, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x52, 0x41, 0x4D, 0x5F, 0x43, 0x41, 0x52, 0x54, 0x52, 0x49, 0x44, 0x47, 0x45, 0x5F, 0x5F, 0x5F,
};

void mcd_fill_blanksave(uint8_t *buffer, uint32_t lba)
{
	if (lba == 0xF)
	{
		memcpy(buffer, int_blank, 512);
	}
	else if (lba == 0x40F)
	{
		memcpy(buffer, ext_blank, 512);
	}
	else
	{
		memset(buffer, 0, 512);
	}
}

int mcd_can_send_data(uint8_t type) {
	if (type == 1) {
		return 1;
	}

	// Ask the FPGA if it is ready to receive a sector
	spi_uio_cmd_cont(UIO_CD_GET);
	spi_w(MCD_GET_SEND_DATA | (type << 2));

	uint16_t data = spi_w(0);
	DisableIO();

	return (data == 1);
}
