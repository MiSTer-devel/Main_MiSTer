
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../cdrom_io.h"
#include "../../cheats.h"
#include "../../file_io.h"
#include "../../hardware.h"
#include "../../menu.h"
#include "../../spi.h"
#include "../../user_io.h"
#include "debug_log.h"
#include "megacd.h"

#define SAVE_IO_INDEX 5 // fake download to trigger save loading

#define MCD_GET_CMD        0
#define MCD_GET_SEND_DATA  1

static int need_reset=0;
static uint8_t has_command = 0;

void mcd_poll()
{
	static uint32_t poll_timer = 0;
	static uint8_t last_req = 255;
	static uint8_t adj = 0;
	static bool load_attempted = false;
	static uint32_t mount_timer = 0;
	static uint32_t hw_poll_timer = 0;
	static int mount_phase = 0; // Moved to function scope

	// Throttle hardware polling to every 500ms to prevent UI freeze
	if (!hw_poll_timer || CheckTimer(hw_poll_timer))
	{
		hw_poll_timer = GetTimer(500);

		if (!hasCDROMMedia(0))
		{
			if (cdd.loaded && load_attempted)
			{
				cdd.Unload();
				Info("CD Removed", 2000);
			}
			else if (!cdd.loaded && cdd.status != CD_STAT_NO_DISC)
			{
				// IDLE STATE FIX: If no media and not loaded, we MUST report NO_DISC.
				// Otherwise, Reset() leaves us in STOP (Ready), confusing the BIOS on startup.
				cdd.status = CD_STAT_NO_DISC;
			}
			load_attempted = false;
			mount_timer = 0;
			mount_phase = 0; // Reset phase on removal
		}
		else if (mount_phase > 0 || (!cdd.loaded && (getCDROMType(0) == DISC_MEGACD || getCDROMType(0) == DISC_UNKNOWN)))
		{
			// Physical CD inserted logic.
			// Condition allows entry if we are ALREADY mounting (mount_phase > 0)
			// OR if we are detecting a new disc.
			if (!load_attempted)
			{
				if (!mount_timer)
				{
					// Phase 0: Start Debounce (force NO_DISC to keep BIOS waiting)
					cdd.status = CD_STAT_NO_DISC;
					mount_phase = 0;
					mount_timer = GetTimer(2000); // 2s spin-up
					Info("Disc Inserted...", 2000);
				}
				else if (CheckTimer(mount_timer))
				{
					if (mount_phase == 0)
					{
						// Phase 1: Force Tray Open (0x05)
						// BIOS: "Close CD Door" / "Open"
						cdd.status = CD_STAT_OPEN;
						mount_timer = GetTimer(2000); // Increased to 2s for visibility
						mount_phase = 1;
						DebugLog("[MISTER] Phase 1: OPEN (Signal: Close Door)\n");
						Info("Close CD Door", 2000);
					}
					else if (mount_phase == 1)
					{
						// Phase 2: Load Data (Hidden under OPEN status)
						// BIOS sees OPEN while we block to read TOC.
						DebugLog("[MISTER] Phase 2: Loading Image (Status: OPEN)\n");
						usleep(50000);
						mcd_set_image(0, "");

						if (cdd.loaded)
						{
							// Load Success -> Signal Door Closed (NO DISC)
							cdd.status = CD_STAT_NO_DISC;
							cdd.latency = 0;
							mount_timer = GetTimer(500); // Wait 500ms as "No Disc" / "Tray Closed"
							DebugLog("[MISTER] Phase 2: Load Success -> Signal NO_DISC\n");
							mount_phase = 2;
						}
						else
						{
							// Load Failed (Drive spinning up?) -> Retry (Stay in Phase 1)
							mount_phase = 1;
							DebugLog("[MISTER] Phase 2: Load Fail (Spinning up?) -> Retry\n");
							// Wait 500ms before retrying, status remains OPEN
							mount_timer = GetTimer(500);
						}
					}
					else if (mount_phase == 2)
					{
						// Phase 3: TOC (Checking Disc)
						cdd.status = CD_STAT_TOC;
						cdd.latency = 0;
						DebugLog("[MISTER] Phase 3: TOC (Reading TOC)\n");
						Info("Checking Disc...", 1500);
						mount_timer = GetTimer(1500); // Hold TOC status for 1.5s
						mount_phase = 3;
					}
					else if (mount_phase == 3)
					{
						// Phase 4: Ready/Stop
						cdd.status = CD_STAT_STOP;
						load_attempted = true;
						DebugLog("[MISTER] Phase 4: STOP (Ready)\n");
						mount_timer = 0;
						mount_phase = 0;
						// The Spy Log in ReadData will trigger shortly after this
						Info("Press Start Button", 2000);
					}
				}
			}
		}
	}

	if (!poll_timer || CheckTimer(poll_timer))
	{
		if (!cdd.isData && cdd.status == CD_STAT_PLAY && cdd.latency == 0) {
			// Send audio sectors faster so buffer stays filled
			poll_timer = GetTimer(10);
			adj = 0;
		} else {
			poll_timer = GetTimer(13 + (!adj ? 1 : 0));
			if (++adj >= 3) adj = 0;
		}

		if (has_command) {
			spi_uio_cmd_cont(UIO_CD_SET);
			uint64_t s = cdd.GetStatus(0);
			spi_w((s >> 0) & 0xFFFF);
			spi_w((s >> 16) & 0xFFFF);
			spi_w(((s >> 32) & 0x00FF) | (cdd.isData ? 0x01 << 8 : 0x00 << 8));
			DisableIO();

			has_command = 0;

			// Log Status Sent to Core
			// Only log if status changed or periodically to avoid spam?
			// For now, log everything to trace handshake "blink"
			uint8_t status_byte = (uint8_t)(s & 0xFF); // stat[1] (Report) | stat[0] (Mode/Status)
			uint8_t stat0_mode = status_byte & 0xF;
			uint8_t stat1_rep = (status_byte >> 4) & 0xF;
			DebugLog("[CORE] < SEND STATUS_WORD: %04X (Mode: %X, Rep: %X, Full: %02X)\n",
				(int)(s & 0xFFFF), stat0_mode, stat1_rep, status_byte);
		}

		cdd.Update();
	}

	uint8_t req = spi_uio_cmd_cont(UIO_CD_GET);
	if (req != last_req)
	{
		last_req = req;

		spi_w(MCD_GET_CMD);

		uint16_t data_in[4];
		data_in[0] = spi_w(0);
		data_in[1] = spi_w(0);
		data_in[2] = spi_w(0);
		DisableIO();

		if (need_reset || data_in[0] == 0xFF) {
			printf("MCD: request to reset\n");
			DebugLog("[CORE] > REQUEST RESET\n");
			need_reset = 0;
			cdd.Reset();
		}

		uint64_t c = *((uint64_t*)(data_in));
		cdd.SetCommand(c, 0);

		// Log Command Received from Core
		DebugLog("[CORE] > GET COMMAND: %02X (Arg: %02X)\n", (int)(c & 0xFF), (int)((c >> 8) & 0xFF));

		cdd.CommandExec();
		has_command = 1;

		//printf("\x1b[32mMCD: Get command, command = %04X%04X%04X, has_command = %u\n\x1b[0m", data_in[2], data_in[1], data_in[0], has_command);
	}
	else
		DisableIO();
}

static char buf[1024];
static void mcd_mount_save(const char *filename)
{
	user_io_set_index(SAVE_IO_INDEX);
	user_io_set_download(1);
	if (strlen(filename))
	{
		FileGenerateSavePath(filename, buf);
		user_io_file_mount(buf, 0, 1);
	}
	else
	{
		user_io_file_mount("");
	}
	user_io_set_download(0);
}

static int mcd_load_rom(const char *basename, const char *name, int sub_index)
{
	strcpy(buf, basename);
	char *p = strrchr(buf, '/');
	if (p)
	{
		p++;
		strcpy(p, name);
		if (user_io_file_tx(buf, sub_index << 6)) return 1;
	}

	return 0;
}

void mcd_set_image(int num, const char *filename)
{
	static char last_dir[1024] = {};

	(void)num;

	cdd.Unload();
	cdd.status = CD_STAT_OPEN;

	int same_game = (*filename && *last_dir && !strncmp(last_dir, filename, strlen(last_dir))) || (!*filename && !*last_dir);
	strcpy(last_dir, filename);
	char *p = strrchr(last_dir, '/');
	if (p) *p = 0;

	int loaded = 1;
	if (!same_game)
	{
		mcd_mount_save("");

		user_io_status_set("[0]", 1);
		user_io_status_set("[0]", 0);
		mcd_reset();

		loaded = 0;
		strcpy(buf, last_dir);
		char *p = strrchr(buf, '/');
		if (p)
		{
			strcpy(p + 1, "cd_bios.rom");
			loaded = user_io_file_tx(buf);
		}
		else
		{
			// Fallback for physical CD/empty path: Try known regions
			const char *bios_paths[] = {"/media/fat/games/MegaCD/USA/cd_bios.rom",
			                            "/media/fat/games/MegaCD/Europe/cd_bios.rom",
			                            "/media/fat/games/MegaCD/Japan/cd_bios.rom",
			                            "/media/fat/games/MegaCD/boot.rom"};
			for (int i = 0; i < 4; i++)
			{
				strcpy(buf, bios_paths[i]);
				loaded = user_io_file_tx(buf);
				if (loaded) break;
			}
		}

		if (!loaded)
		{
			sprintf(buf, "%s/boot.rom", HomeDir());
			loaded = user_io_file_tx(buf);
		}

		if (!loaded) Info("CD BIOS not found!", 4000);
	}

	if (loaded && (*filename || hasCDROMMedia(0)))
	{
		if (cdd.Load(filename) > 0)
		{
			cdd.status = cdd.loaded ? CD_STAT_STOP : CD_STAT_NO_DISC;
			cdd.latency = 10;
			cdd.SendData = mcd_send_data;
			cdd.CanSendData = mcd_can_send_data;

			if (!same_game)
			{
				mcd_load_rom(filename, "cd_bios.rom", 0);
				mcd_load_rom(filename, "cart.rom", 1);
				mcd_mount_save(filename);
				cheats_init(filename, 0);
			}
		}
		else
		{
			cdd.status = CD_STAT_NO_DISC;
		}
	}
}

void mcd_reset() {
	need_reset = 1;
}

int mcd_send_data(uint8_t* buf, int len, uint8_t index) {
	// set index byte
	user_io_set_index(index);

	user_io_set_download(1);
	user_io_file_tx_data(buf, len);
	user_io_set_download(0);
	return 1;
}

static char int_blank[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x7D, 0x00, 0x7D, 0x00, 0x7D, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x53, 0x45, 0x47, 0x41, 0x5F, 0x43, 0x44, 0x5F, 0x52, 0x4F, 0x4D, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x52, 0x41, 0x4D, 0x5F, 0x43, 0x41, 0x52, 0x54, 0x52, 0x49, 0x44, 0x47, 0x45, 0x5F, 0x5F, 0x5F,
};

static char ext_blank[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x5F, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x1F, 0xFD, 0x1F, 0xFD, 0x1F, 0xFD, 0x1F, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x53, 0x45, 0x47, 0x41, 0x5F, 0x43, 0x44, 0x5F, 0x52, 0x4F, 0x4D, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x52, 0x41, 0x4D, 0x5F, 0x43, 0x41, 0x52, 0x54, 0x52, 0x49, 0x44, 0x47, 0x45, 0x5F, 0x5F, 0x5F,
};

void mcd_fill_blanksave(uint8_t *buffer, uint32_t lba)
{
	if (lba == 0xF)
	{
		memcpy(buffer, int_blank, 512);
	}
	else if (lba == 0x40F)
	{
		memcpy(buffer, ext_blank, 512);
	}
	else
	{
		memset(buffer, 0, 512);
	}
}

int mcd_can_send_data(uint8_t type) {
	if (type == 1) {
		return 1;
	}

	// Ask the FPGA if it is ready to receive a sector
	spi_uio_cmd_cont(UIO_CD_GET);
	spi_w(MCD_GET_SEND_DATA | (type << 2));

	uint16_t data = spi_w(0);
	DisableIO();

	return (data == 1);
}
